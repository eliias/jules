/*
 * License: MIT http://opensource.org/licenses/MIT
 * do not edit this file directly - as it will get updated automatically width MightyEditor update
 */
(function(global){
	"use strict";
	// phaser script loader that shows scripts in the chrome's dev console
	var _loadFile = Phaser.Loader.prototype.loadFile;

	Phaser.Loader.prototype.loadFile = function(){
		var file = this._fileList[this._fileIndex];
		this.onFileStart.dispatch(this.progress, file.key, file.url);
		
		if(file.type == "font"){
			this.fontLoad(this._fileIndex, file.key, 'text', 'fileComplete', 'fileError');
			return;
		}
		
		if(file.type != "script"){
			_loadFile.call(this);
			return;
		}
		
		this.scriptLoad(this._fileIndex, this.baseURL + file.url, 'text', 'fileComplete', 'fileError');
	};

	Phaser.Loader.prototype.scriptLoad = function (index, url, type, onload, onerror) {
		var script = document.createElement("script");
		script.src = url;
		var _this = this;
		script.onload = function(){
			window.setTimeout(function(){
				_this[onload](index);
			}, 0);
		};
		script.onerror = function(){
			return _this[onerror](index);
		};
		document.body.appendChild(script);
	};
	// end script loader
	
	// phaser font loader - make phaser loader to wait for font
	
	Phaser.Loader.prototype.font = function(key, url, callback, callbackContext){
		if (typeof callback === 'undefined') { callback = false; }
		if (callback !== false && typeof callbackContext === 'undefined') { callbackContext = callback; }

		this.addToFileList('font', key, url, { callback: callback, callbackContext: callbackContext });

		return this;
	};
	
	
	/* todo - add css style generator */
	Phaser.Loader.prototype.fontLoad = function (index, url, type, onload, onerror) {
		var file = this._fileList[this._fileIndex];
		this.onFileStart.dispatch(this.progress, file.key, file.url);
		
		if(this.game.device.cocoonJS){
			this[onload](index);
			return;
		}
		
		var _this = this;
		var span = document.createElement("span");
		span.style.fontFamily = "Comic Sans MS";
		span.style.position = "fixed";
		span.style.top = "-1000px";
		
		
		span.appendChild(document.createTextNode("`1234567890-=qwertyuiop[]\asdfghjkl;'zxcvbnm,./~!@#$%^&*()_+QWERTYUIOP{}ASDFGHJKL:ZXCVBNM<>?"));
		document.body.appendChild(span);
		
		var csmsBox = span.getBoundingClientRect();
		span.style.fontFamily = file.key;
		
		//span.style;
		var checkLoaded = function(){
			var newBox = span.getBoundingClientRect();
			if(csmsBox.width != newBox.width || csmsBox.height != newBox.height){
				document.body.removeChild(span);
				for(var i in PIXI.Text.heightCache){
					delete PIXI.Text.heightCache[i];
				}
				_this[onload](index);
			}
			else{
				window.setTimeout(checkLoaded, 100);
			}
		};
		window.setTimeout(checkLoaded, 100);
	};
	
	var data = null;
	if(global.mt && global.mt.data){
		data = global.mt.data;
	}
	
	global.mt = {
		
		SPRITE: 0,
		GROUP: 1,
		TEXT: 2,
		TILE_LAYER: 3,
		
		knownFonts: [
			"Arial",
			"Comic Sans MS",
			"Courier New",
			"Georgia",
			"Impact",
			"Times New Roman",
			"Trebuchet MS",
			"Verdana"
		],
 
		assets: {},
		objects: {},
	
		assetsPath: "assets",
		game: null,
	
		data: data,
		mainMovie: "__main",
		autoLoadFonts: true,
		
		init: function(game){
			this.game = game;
			this.game.load.crossOrigin = "anonymous";
			
			
			
			if(Phaser.VERSION == "2.0.7"){
				this.game.load.script("hacks", "js/lib/phaserHacks2.0.7.js");
			}
			else if(Phaser.VERSION == "2.1.3"){
				this.game.load.script("hacks", "js/lib/phaserHacks2.1.3.js");
			}
			else{
				this.game.load.script("hacks", "js/lib/phaserHacks.js");
			}
			
		},
 
		setBackgroundColor: function(appendToBody){
			
			if(this.data.map.backgroundColor){
				var tmp = this.data.map.backgroundColor.substring(1);
				var bg = parseInt(tmp, 16);
				
				if(this.game.stage.backgroundColor != bg){
					this.game.stage.setBackgroundColor(bg);
				}
			}
			
			if(appendToBody){
				document.body.style.backgroundColor = this.data.map.backgroundColor;
			}
		},
 
		// preload all assets
		preload: function(){
			this._loadAssets(this.data.assets.contents, this.assets, "");
			this._loadFonts(this.data.objects);
		},
		
		// load assets for seperate object group
		loadGroup: function(name){
			var toLoad = {};
			var group = this.getObjectGroupByName(name);
			if(!group){
				console.error("failed to load group: ", name);
				return;
			}
			this._collectAssets(group, toLoad);
			this._loadAssetBuffer(toLoad);
			
			this._loadFonts(group);
			
		},
		
		// create full map
		createAll: function(){
			var all = {};
			this._loadObjects(this.data.objects.contents, this.game.world, "", all, true);
			
			for(var i in all){
				this.createTweens(all[i], this.mainMovie);
			}
			
			return all;
		},
		
		createTweens: function(phaserObject, name){
			var movie, movies, mdata;
			var obj = phaserObject.mt;
			obj.movies = {};
			
			movies = obj.movies;
			mdata = obj.data.movies;
			if(name == void(0)){
				for(var mov in mdata){
					if(mov == this.mainMovie){
						continue;
					}
					movies[mov] = new mt.TweenCollection(mov, obj);
				}
			}
			else{
				movies[name] = new mt.TweenCollection(name, obj);
			}
		},
		
		/**
		* create sprite or group from name
		* @param {string} name - name of the object
		* @param {Group} [parent] - parent of the created object group or sprite
		*/
		create: function(name, parent){
			parent = parent || this.game.world;
			var data = this.getObjectGroupByName(name);
			if(!data){
				console.error("failed to find the object: ", name);
				return;
			}
			
			return this._add(data, parent, "");
		},
		/**
		 * same as mt.create
		 */
		createGroup: function(name, parent){
			return mt.create(name, parent);
		},
		
		// create slope map for tilelayer
		createSlopeMap: function(layer){
			var map = {};
			var data = layer.layer.data;
			var i=0, j=0;
			
			for( ;i<data.length; i++){
				for(j=0; j<data[i].length; j++){
					if(data[i][j].index > 0){
						map[i*data[i].length + j] = data[i][j].index;
					}
				}
			}
			return map;
		},

		getObjectData: function(name, container){
			if(typeof name == "object"){
				name = name.name;
			}
			
			container = container || this.data.objects;
			
			if(container.contents){
				for(var i=0; i<container.contents.length; i++){
					if(container.contents[i].contents){
						this.getObjectData(name, container.contents[i]);
					}
					else{
						if(container.contents[i].name == name){
							return container.contents[i];
						}
					}
				}
			}
			if(container.name == name){
				return container;
			}
		},
 
		getAssetPath: function(asset){
			return this.assetsPath + asset.fullPath;
		},
		
		getObjectGroupByName: function(name, container){
			container = container || this.data.objects.contents;
			var ret;
			for(var i = 0; i < container.length; i++){
				if(container[i].name == name){
					return container[i];
				}
				if(container[i].contents){
					ret = this.getObjectGroupByName(name, container[i].contents);
					if(ret){
						return ret;
					}
				}
			}
		},
		
		getAssetByName: function(name, container){
			container = container || this.data.assets.contents;
			for(var i in container){
				if(container[i].name == name){
					return container[i];
				}
				if(container[i].contents){
					ret = this.getAssetById(id, container[i].contents);
					if(ret){
						return ret;
					}
				}
			}
			
			return ret;
		},
		
		getAssetById: function(id, container){
			container = container || this.data.assets.contents;
			var ret = null;
			
			for(var i in container){
				if(container[i].id == id){
					return container[i];
				}
				if(container[i].contents){
					ret = this.getAssetById(id, container[i].contents);
					if(ret){
						return ret;
					}
				}
			}
			
			return ret;
		},
		
		getObjectByName: function(name, container){
			container = container || this.data.objects.contents;
			for(var i in container){
				if(container[i].name == name){
					return container[i];
				}
				if(container[i].contents){
					ret = this.getObjectById(id, container[i].contents);
					if(ret){
						return ret;
					}
				}
			}
			
			return ret;
		},
		
		physics: {
			ninja: {
				enableTileLayer: function (layer) {
					layer = layer.layer;
					for (var y = 0, h = layer.height; y < h; y++){
						for (var x = 0, w = layer.width; x < w; x++){
							var tile = layer.data[y][x];
							if (tile && tile.index > 0){
								var body = new Phaser.Physics.Ninja.Body(this, null, 3, tile.index, 0, tile.worldX + tile.centerX, tile.worldY + tile.centerY, tile.width, tile.height);
								layer.bodies.push(body);
							}
						}
					}
					return layer.bodies;
				}
			}
		},
 
 
		/* private stuff */
		_loadAssetBuffer: function(buffer){
			var container;
			var asset = null;
			for(var i in buffer){
				asset = buffer[i];
				
				container = this._getAssetContainer(asset);
				this._addAsset(asset, container);
			}
		},
 		
		_loadFonts: function(group){
			var object;
			for(var i=0; i<group.contents.length; i++){
				object = group.contents[i];
				if(object.contents){
					this._loadFonts(object);
					continue;
				}
				if(object.type == mt.TEXT){
					if(this.knownFonts.indexOf(object.style.fontFamily) != -1){
						continue;
					}
					this.game.load.font(object.style.fontFamily);
				}
			}
		},
 
		_mkDiff: function(o1, o2, flip){
			var out = {};
			for(var i in o1){
				if(i == "keyframe"){
					continue;
				}
				if(typeof o1[i] === "object"){
					continue;
				}
				if(o1[i] === void(0)){
					continue;
				}
				if(o1[i] != o2[i]){
					out[i] = o2[i] - o1[i] + "";
				}
			}
			for(var i in o2){
				if(i == "keyframe"){
					continue;
				}
				if(typeof o2[i] === "object"){
					continue;
				}
				if(o1[i] === void(0)){
					continue;
				}
				if(o1[i] != o2[i]){
					out[i] = o2[i] - o1[i] + "";
				}
			}
			return out;
		},

		_getAssetContainer: function(asset){
			var cont = this.assets;
			var path = asset.fullPath.split("/");
			path.shift();
			for(var i=0; i<path.length-1; i++){
				cont[path[i]] = cont[path[i]] || {};
				cont = cont[path[i]];
			}
			return cont;
		},
 
		_getObjectContainer: function(object){
			var cont = this.assets;
			var path = asset.fullPath.split("/");
			path.shift();
			for(var i=0; i<path.length-1; i++){
				cont[path[i]] = cont[path[i]] || {};
				cont = cont[path[i]];
			}
			return cont;
		},
 
		_collectAssets: function(group, buffer){
			var id, object, asset;
			for(var i=0; i<group.contents.length; i++){
				object = group.contents[i];
				if(object.contents){
					this._collectAssets(object, buffer);
				}
				id = object.assetId;
				asset = this.getAssetById(id);
				if(asset){
					buffer[id] = asset;
				}
			}
		},
 
		_loadAssets: function(data, container){
			var asset = null;
			
			for(var i = 0, l = data.length; i<l; i++){
				asset = data[i];
				if(asset.contents && asset.contents.length){
					if(container[asset.name] === void(0)){
						container[asset.name] = {};
					}
					this._loadAssets(asset.contents, container[asset.name]);
				}
				else{
					this._addAsset(asset, container);
				}
			}
		},
	
		_addAsset: function(asset, container){
			var path = this.assetsPath + asset.fullPath;
			var that = this;
			if(!asset.key){
				return;
			}
			
			// is already loaded ?
			if(container[asset.name]){
				return;
			}
			
			if(asset.atlas){
				this.game.load.atlas(asset.key, this.assetsPath + asset.fullPath, this.assetsPath + "/" + asset.atlas, null,  asset.type);
			}
			else if(asset.width != asset.frameWidth || asset.height != asset.frameHeight){
				this.game.load.spritesheet(asset.key, this.assetsPath + asset.fullPath, asset.frameWidth, asset.frameHeight, asset.frameMax, asset.margin, asset.spacing);
			}
			else{
				this.game.load.image(asset.key, this.assetsPath + asset.fullPath);
			}
			
			
			Object.defineProperty(container, asset.name, {
				get : function(){ 
					return asset;
				},
				enumerable: true
			});
			
		},
		
		_loadObjects: function(children, parent, path, ref, keepVisibility){
			parent = parent || this.game.world;
			path = path !== "" ? "." + path : path;
			
			for(var i = children.length - 1; i > -1; i--){
				ref[children[i].name] = this._add(children[i], parent, path, keepVisibility);
			}
		},
		
		_add: function(data, parent, path, keepVisibility){
			var createdObject = null;
			
			if(data.type == this.GROUP){
				createdObject = this._addGroup(data);
				
				if(data.physics && data.physics.enable){
					createdObject.enableBody = true;
				}
				parent.add(createdObject);
				
				createdObject.mt = {
					self: createdObject,
					data: data,
					children: {}
				};
				
				this._updateCommonProperties(data, createdObject, keepVisibility);
				this._loadObjects(data.contents, createdObject, path + data.name, createdObject.mt.children, keepVisibility);
			}
			else{
				if(data.type == this.TEXT){
					createdObject = this._addText(data, parent);
				}
				else if(data.type == this.TILE_LAYER){
					createdObject = this._addTileLayer(data, parent);
					if(data.physics && data.physics.enable){
						createdObject.map.setCollisionByExclusion([-1]);
					}
				}
				else{
					createdObject = this._addObject(data, parent);
					
					this.addPhysics(data, createdObject, (parent.mt ? parent.mt.data : null));
				}
				
				this._updateCommonProperties(data, createdObject, keepVisibility);
				
				createdObject.mt = {
					self: createdObject,
					data: data,
					children: {}
				};
				
				if(data.contents){
					this._loadObjects(data.contents, createdObject, path + data.name, createdObject.mt.children, keepVisibility);
				}
			}
			
			createdObject.self = createdObject;
			createdObject.getData = function(){
				return this.mt.data;
			};
			return createdObject;
		},
		
		addPhysics: function(tpl, sprite, parent){
			var p = tpl.physics;
			if(!p || !p.enable){
				if(parent && parent.physics && parent.physics.enable){
					p = parent.physics;
				}
			}
			if(p && p.enable){
				this.game.physics.arcade.enable(sprite);
				
				sprite.body.allowGravity = p.gravity.allow;
				sprite.body.gravity.x = p.gravity.x;
				sprite.body.gravity.y = p.gravity.y;
				
				sprite.body.immovable = p.immovable;
				
				sprite.body.bounce = p.bounce;
				
				sprite.body.maxAngular = p.rotation.maxAngular;
				sprite.body.allowRotation = p.rotation.allowRotation;
				
				sprite.body.maxVelocity = p.maxVelocity;
				
				sprite.body.mass = p.mass;
				sprite.body.collideWorldBounds = p.collideWorldBounds;
				
				var w = sprite.width;
				var h = sprite.height;
				if(p.size.width > 0){
					w = p.size.width;
				}
				if(p.size.height > 0){
					h = p.size.height;
				}
				
				sprite.body.setSize(w, h, p.size.offsetX, p.size.offsetY);
			}
		},
 
		_addGroup: function(object){
			var group = this.game.add.group();

			group.x = object.x;
			group.y = object.y;
			group.fixedToCamera = !!object.fixedToCamera;
			
			if(object.angle){
				group.angle = object.angle;
			}
			group.alpha = object.alpha || 1;
			
			return group;
		},
		
		_addText: function(object, group){
			group = group || this.game.world;
			var t = this.game.add.text(object.x, object.y, object.text || object.name, object.style);
			group.add(t);
			return t;
		},
		
		_addTileLayer: function(object, group){
			group = group || this.game.world;
			var map = this.game.add.tilemap(null, object.tileWidth, object.tileHeight, object.widthInTiles, object.heightInTiles);
			
			var tl = map.createBlankLayer(object.name, object.widthInTiles, object.heightInTiles, object.tileWidth, object.tileHeight);
			
			var nextId = 0;
			var im = null;
			var asset = "";
			for(var i=0; i<object.images.length; i++){
				asset = this.getAssetById(object.images[i]);
				
				if(asset){
					im = map.addTilesetImage(asset.key, asset.key, asset.frameWidth, asset.frameHeight, asset.margin, asset.spacing, nextId);
					nextId += im.total;
				}
				else{
					console.warn("cannot find image", object.images[i]);
				}
			}
			
			var tiles = object.tiles;
			var tile = null;
			for(var y in tiles){
				for(var x in tiles[y]){
					tile = map.putTile(tiles[y][x], parseInt(x, 10), parseInt(y, 10), tl);
				}
			}
			tl.fixedToCamera = object.isFixedToCamera;
			return tl;
		},
		
		_addObject: function(object, group){
			
			var sp = null;
			group = group || this.game.world;
			
			if(group.type == Phaser.GROUP){
				sp = group.create(object.x, object.y, object.assetKey);
			}
			else{
				sp = this.game.add.sprite(object.x, object.y, object.assetKey);
				
				this.game.world.removeChild(sp);
				group.addChild(sp);
			}
			
			
			var frameData = this.game.cache.getFrameData(object.assetKey);
			
			if(frameData){
				var arr = [];
				for(var i=0; i<frameData.total; i++){
					arr.push(i);
				}
				sp.animations.add("default", arr, (object.fps !== void(0) ? object.fps : 10) , false);
				sp.frame = object.frame;
			}
			return sp;
		},
 
		_updateCommonProperties: function(template, object, keepVisibility){
			
			if(template.angle){
				object.angle = template.angle;
			}
			
			if(template.type !== mt.GROUP && object.type != Phaser.GROUP){
				object.anchor.x = template.anchorX;
				object.anchor.y = template.anchorY;
				if(template.scaleX != void(0)){
					object.scale.x = template.scaleX;
					object.scale.y = template.scaleY;
				}
			}
			
			object.x = template.x;
			object.y = template.y;
			object.alpha = template.alpha || 1;
			
			if(keepVisibility){
				object.visible = template.isVisible;
			}
		},
		
		//mark all texts dirty to force redraw
		_markDirty: function(group){
			group = group || game.world.children;
			
			var child = null;
			for(var i=0; i<group.length; i++){
				child = group[i];
				
				if(child.type == Phaser.TEXT){
					child.dirty = true;
					continue;
				}
				
				if(child.type == Phaser.GROUP){
					this.markDirty(child.children);
				}
			}
		}
	};
	var TweenCollection = function(movieName, pack, fps, length, delay, manager){
		this.name = movieName;
		
		this.onComplete = new Phaser.Signal();
		this._pack = pack;
		this._tweens = [];
		this._subtweens = [];
		this._mainTimer = null;
		this._startPos = [];
		if(manager){
			this.manager = manager;
		}
		else{
			
			this.manager = new Phaser.TweenManager(mt.game);
			this.manager.destroy = function(){};
			this.manager.update = function() {
				var addTweens = this._add.length;
				var numTweens = this._tweens.length;
				
				if (numTweens === 0 && addTweens === 0){
					return false;
				}
				var i = 0;
				while (i < numTweens){
					if (this._tweens[i].update(this.game.time.now)){
						i++;
					}
					else{
						this._tweens.splice(i, 1);
						numTweens--;
					}
				}
				//  If there are any new tweens to be added, do so now - otherwise they can be spliced out of the array before ever running
				if (addTweens > 0){
					this._tweens = this._tweens.concat(this._add);
					this._add.length = 0;
				}
				
				
				return true;
			};
		}
		
		this._delay = delay;
		this._length = length;
		
		if(fps != void(0)){
			this._fps = fps;
			this._ifps = 1000/this._fps;
		}
		
		if(length != void(0)){
			this._lastFrame = length;
		}
		
		this._buildTweens(this._pack, true);
		
		if(movieName != mt.mainMovie){
			this._buildChildTweens(this._pack.children);
		}
		
	};
	
	TweenCollection.prototype = {
		isLooping: false,
		_fps: -1,
		_lastFrame: -1,
		_buildTweens: function(pack, isMain){
			var start, stop, tween, easings;
			if(!pack.data.movies){
				return;
			}
			var movie = pack.data.movies[this.name];
			if(!movie){
				return null;
			}
			if(isMain){
				if(this._fps == -1){
					if(movie.subdata){
						this._fps = mt.data.map.movieInfo.fps;
						
					}
					else{
						this._fps = movie.info.fps || mt.data.map.movieInfo.fps;
					}
					this._ifps = 1000/this._fps;
					
				}
				if(this._lastFrame == -1){
					if(movie.subdata){
						this._lastFrame = mt.data.map.movieInfo.lastFrame;
						
					}
					else{
						this._lastFrame =  movie.info.lastFrame || mt.data.map.movieInfo.lastFrame;
					}
					
				}
				this._mainTimer = mt.game.time.create(false);
				
				if(movie.subdata && movie.subdata.length > 0){
					this._buildSubTweens(movie.subdata);
				}
			}
			
			if(movie.frames.length === 0){
				return null;
			}
			
			var start = movie.frames[0];
			this._startPos.push({obj: pack.self, start: start});
			
			for(var k in start){
				tween = null;
				delay = this._delay;
				for(var i=0; i<movie.frames.length - 1; i++){
					start = movie.frames[i];
					stop = movie.frames[i+1];
					if(start.keyframe > this._lastFrame){
						break;
					}
					var ea = null;
					if(stop.easings){
						ea = stop.easings[k];
					}
					
					/*var ss = mt._mkDiff(start, stop);
					if(!ss[k]){
						continue;
					}*/
					var tmp = {};
					tmp[k] = stop[k];
					
					tween = this._addTween(pack.self, start, stop, ea, tween, tmp, delay);
					delay = 0;
				}
				if(tween){
					this._tweens.push(tween);
				}
			}
			
			
			
			
			/*if(this._length > len){
				tween = tween.delay((this._length - len)*this._ifps);
			}*/
			
			
			return;
		},
		
		_buildChildTweens: function(children){
			var child;
			for(var key in children){
				child = children[key];
				if(!child.mt || !child.mt.data.movies || !child.mt.data.movies[this.name]){
					continue;
				}
				this._buildTweens(child.mt);
				this._buildChildTweens(child.mt.children);
			}
		},
		
		_buildSubTweens: function(sub){
			var st, innerData, delay, frame;
			var that = this;
			
			for(var i=0; i<sub.length; i++){
				innerData = sub[i].movies[this.name];
				if(!innerData || !innerData.frames || innerData.frames.length === 0){
					continue;
				}
				for(var c in this._pack.children){
					for(var fi=0; fi<innerData.frames.length; fi++){
						frame = innerData.frames[fi];
						
						st = new TweenCollection(sub[i].name, this._pack.children[c].mt, this._fps, Math.min(frame.length + frame.keyframe, this._lastFrame)*this._ifps, frame.keyframe);
						this._addSubTween(st);
					}
				}
			}
		},
		
		_mk_sub: function(timer, delay, name, children){
			var that = this;
			return function(){
				timer.add(delay, function(){
					that._playChildren(name, children);
				});
				timer.start();
			}
		},
		_playChildren: function(movie, children){
			for(var c in children){
				children[c].mt.movies[movie].start().loop();
			}
		},
 
		/*
		 * TODO: make easings work
		 */
		_addTween: function(obj, start, stop, easing, nextTween, to, delay){
			var tween;
			var st = start.keyframe * this._ifps;
			var et = (stop.keyframe - start.keyframe) * this._ifps;
			
			if(!nextTween){
				tween = new Phaser.Tween(obj, mt.game, this.manager);
				if(delay){
					tween = tween.delay(delay * this._ifps);
				}
			}
			else{
				tween = nextTween;
			}
			
			var ea = null;
			if(easing){
				ea = Phaser.Easing;
				var t = easing.split(".");
				while(t.length){
					ea = ea[t.shift()];
				}
			}
			
			tween = tween.to(to, et, ea);
			return tween;
		},
 
		_addSubTween: function(tween){
			this._subtweens.push(tween);
		},
		_stop: function(reset){
			mt.game.plugins.remove(this.manager);
			this.manager.removeAll();
			this.manager.update();
			
			var i, j, tween, l;
			this._mainTimer.stop();
			
			for(i=0; i<this._subtweens.length; i++){
				this._subtweens[i].stop(reset);
			}
			
			for(i=0; i<this._tweens.length; i++){
				this._tweens[i].stop();
				tween = this._tweens[i];
				for(j=0, l = tween._chainedTweens.length; j<l; j++){
					tween = tween._chainedTweens[j];
					tween.stop();
				}
			}
			
			if(reset){
				this.reset();
			}
		},
		start: function(){
			var i, j, tween;
			if(!this._subtweens.length && !this._tweens.length){
				return this;
			}
			
			if(!this._mainTimer){
				return this;
			}
			
			mt.game.plugins.add(this.manager);
			
			this._mainTimer.removeAll();
			
			this._mainTimer.add(this._ifps * this._lastFrame, this._complete, this);
			this._mainTimer.start();
			this.reset();
			this.resume();
			
			for(i=0; i<this._subtweens.length; i++){
				this._subtweens[i].start();
			}
			
			for(i=0; i<this._tweens.length; i++){
				tween = this._tweens[i];
				tween._paused = false;
				tween.pendingDelete = false;
				tween.start();
				
				
				for(j=0,l=tween._chainedTweens.length; j<l; j++){
					tween = tween._chainedTweens[j];
					tween._paused = false;
					tween.pendingDelete = false;
				}
			}
			
			
			return this;
		},
		stop: function(reset){
			
			this._stop();
			if(reset){
				this.reset();
			}
			this.isLooping = false;
			
			return this;
		},
		
		reset: function(){
			var op, sub;
			for(var i=0; i<this._startPos.length; i++){
				op = this._startPos[i];
				for(var k in op.start){
					op.obj[k] = op.start[k];
				}
			}
		},
		pause: function(){
			var i, j, tween;
			this._mainTimer.pause();
			for(i=0; i<this._tweens.length; i++){
				tween = this._tweens[i];
				tween.pause();
				for(j=0; j<tween._chainedTweens.length; j++){
					tween = tween._chainedTweens[j];
					tween.pause();
				}
			}
			for(i=0; i<this._subtweens.length; i++){
				this._subtweens[i].pause();
			}
			
			return this;
		},
		resume: function(){
			var i, j, tween;
			this._mainTimer.resume();
			for(i=0; i<this._tweens.length; i++){
				tween = this._tweens[i];
				tween.resume();
				for(j=0; j<tween._chainedTweens.length; j++){
					tween = tween._chainedTweens[j];
					tween.resume();
				}
				
				
			}
			for(i=0; i<this._subtweens.length; i++){
				this._subtweens[i].resume();
			}
			
			return this;
		},
		
		delay: function(ms){
			this.delay.removeAll();
			this._delay.add(ms, this.start, this);
			return this;
		},
		
		loop: function(){
			if(this.isLooping){
				return;
			}
			this.isLooping = true;
			for(var i=0; i<this._subtweens.length; i++){
				this._subtweens[i].loop();
			}
			return this;
		},
		
		_complete: function(){
			this.onComplete.dispatch(this);
			this._stop();
			if(this.isLooping){
				this.start();
			}
		}
		
	};
	
	global.mt.TweenCollection = TweenCollection;
})(typeof window == "undefined" ? global : window);
